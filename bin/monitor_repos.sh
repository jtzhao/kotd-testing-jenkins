#!/bin/bash

# ****************************************************************************
# Copyright (c) 2013 Unpublished Work of SUSE. All Rights Reserved.
# 
# THIS IS AN UNPUBLISHED WORK OF SUSE.  IT CONTAINS SUSE'S
# CONFIDENTIAL, PROPRIETARY, AND TRADE SECRET INFORMATION.  SUSE
# RESTRICTS THIS WORK TO SUSE EMPLOYEES WHO NEED THE WORK TO PERFORM
# THEIR ASSIGNMENTS AND TO THIRD PARTIES AUTHORIZED BY SUSE IN WRITING.
# THIS WORK IS SUBJECT TO U.S. AND INTERNATIONAL COPYRIGHT LAWS AND
# TREATIES. IT MAY NOT BE USED, COPIED, DISTRIBUTED, DISCLOSED, ADAPTED,
# PERFORMED, DISPLAYED, COLLECTED, COMPILED, OR LINKED WITHOUT SUSE'S
# PRIOR WRITTEN CONSENT. USE OR EXPLOITATION OF THIS WORK WITHOUT
# AUTHORIZATION COULD SUBJECT THE PERPETRATOR TO CRIMINAL AND  CIVIL
# LIABILITY.
# 
# SUSE PROVIDES THE WORK 'AS IS,' WITHOUT ANY EXPRESS OR IMPLIED
# WARRANTY, INCLUDING WITHOUT THE IMPLIED WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT. SUSE, THE
# AUTHORS OF THE WORK, AND THE OWNERS OF COPYRIGHT IN THE WORK ARE NOT
# LIABLE FOR ANY CLAIM, DAMAGES, OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT, OR OTHERWISE, ARISING FROM, OUT OF, OR IN CONNECTION
# WITH THE WORK OR THE USE OR OTHER DEALINGS IN THE WORK.
# ****************************************************************************

# import libs
BIN_DIR=$(dirname "$0")
LIB_DIR="$BIN_DIR/../lib"
source "${LIB_DIR}/utils.sh"

# Description: Print usage info
usage()
{
	cat <<END
Usage: $0 [options] [url]"
	url: where kotd kernels are in. Default: ${KOTD_URL}
	-h | --help: print usage info
	-f | --file: the file which records already tested kernels. Default: ${RECORD_FILE}
	-r | --release: SLE release, e.g. SLE12-SP1
	-d | --debug: prints debug info
END
}


# Description: Get all the package file names from $URL.
# Parameter:	$1 - url where kotd kernels are
# Output:	Prints the package file list if pass
# Return:  	0 - pass
#		1 - fail
get_filelist() {
	url=$1
	regexp="(?<=<a href=\")[^\"]+\\.rpm"
	cmd="curl -s '$url' | grep -oP '$regexp' | sort -h | uniq"
	file_list=$(run $FUNCNAME "$cmd")
	if [[ -n "$file_list" ]]; then
		echo "$file_list"
		return 0
	else
		return 1
	fi
}


# Description: 	Get the latest version of the given package
# Parameter:	$1 - URL of the package list or file list generated by get_filelist()
#		$2 - name of the package to be checked(e.g. kernel-default-base)
# Output:	Prints the latest version if pass
# Return:  	0 - pass
#		1 - fail
get_latest_version() {
	url_or_filelist=$1
	package_name=$2
	# Get the version of packages
	# Get filelist if $url_or_filelist is an url
	if [[ "$url_or_filelist" == http* ]]; then
		debug $FUNCNAME "Getting package list from $url_or_filelist"
		cmd="get_filelist '$url_or_filelist'"
		url_or_filelist=$(run $FUNCNAME "$cmd")
	fi
	# Get versions of specific package
	if [[ -z "$url_or_filelist" ]]; then
		return 1
	fi
	regexp="(?<=${package_name}-)(\\d+[\\-.])+"
	cmd="echo '$url_or_filelist' | grep -oP '$regexp'"
	versions=$(run $FUNCNAME "$cmd")
	debug $FUNCNAME "package versions: $versions"
	# Get latest version
	latest="0.0.0.0.0."
	for version in $(echo "$versions")
	do
		version_cmp "$version" "$latest"
		if [[ $? -eq 1 ]]; then
			latest=$version
		fi
	done
	if [[ "$latest" != "0.0.0.0.0." ]]; then
		echo "$latest"
		return 0
	else
		return 1
	fi
}


################################################################################
#			Main Entrance
################################################################################
# Parse arguments
ARGS=$(getopt -o dhf:r: -l debug,help,file:,release: -- "$@")
eval set -- "${ARGS}"
while true
do
	case "$1" in
		-h|--help)
			usage
			exit 0
			;;
		-f|--file)
			RECORD_FILE=$2
			shift 2
			;;
		-r|--release)
			OS_RELEASE=$2
			shift 2
			;;
		-d|--debug)
			DEBUG=true
			shift
			;;
		--)
			shift
			break
			;;
		*)
			echo "Internal error!"
			usage
			exit 255
			;;
	esac
			
done
# parse remaining arguments
if [[ $# -gt 1 ]]; then
	usage
	exit 255
elif [[ $# -eq 1 ]]; then
	KOTD_URL="$1"
fi
# validate arguments
if [[ -z "$OS_RELEASE" ]]; then
	echo "Missing argument: -r | --release"
	usage
	exit 255
fi
if  [[ "$KOTD_URL" != http* ]]; then
	echo "Invalid argument: KOTD_URL must be an http url"
	exit 255
fi
# create record file if necessary
if ! [[ -f "$RECORD_FILE" ]]; then
	mkdir -p $(dirname "$RECORD_FILE")
	touch $RECORD_FILE
	if [[ $? -ne 0 ]]; then
		echo "Failed to create record file: $RECORD_FILE"
		exit 255
	fi
fi
# check kotd kernel for every arch
for arch in $(echo "$ARCHS" | sed -e 's/,/ /g')
do
	url="${KOTD_URL}/${OS_RELEASE}/standard/$arch/"
	file_list=$(get_filelist "$url")
	if [[ $? -ne 0 ]]; then
		echo "Failed to get kotd package list from $url"
		exit 1
	fi
	latest=$(get_latest_version "$file_list" "$KOTD_PACKAGE_NAME")
	if [[ $? -ne 0 ]]; then
		echo "Failed to get latest kotd version"
		exit 2
	fi
	echo "latest version of $KOTD_PACKAGE_NAME: $latest"
	# check if latest version is tested
	regexp=$(echo "^${OS_RELEASE} ${KOTD_PACKAGE_NAME} ${arch} ${latest}$" | sed -e 's/\./\./g')
	grep -P "$regexp" "$RECORD_FILE" &> /dev/null
	if [[ $? -eq 0 ]]; then
		echo "$KOTD_PACKAGE_NAME $latest is already tested"
	else
		next_job="REGRESSIONTEST/job/KOTD_${OS_RELEASE}/job/arch-${arch}/job/02_InstallKotd"
		trigger_jenkins "${JENKINS_URL}/job/${next_job}/buildWithParameters" "REPOSITORY=${url}"
		if [[ $? -eq 0 ]]; then
			# Add version to record file
			echo -e "Successfully triggered jenkins job\n"
			echo "${OS_RELEASE} ${KOTD_PACKAGE_NAME} ${arch} ${latest}" >> "$RECORD_FILE"
		else
			echo "Failed to trigger jenkins job"
		fi
	fi
done
exit 0
